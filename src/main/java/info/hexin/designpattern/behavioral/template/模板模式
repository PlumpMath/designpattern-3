在面向对象的分析和设计中经常遇到这样一种情况：对于某一个业务逻辑(算法实现)在不同的对象中有不同的细节实现，
但逻辑(算法)的框架(或通用的应用算法)是相同的，Template模式提供了这种情况的一个实现框架。
Template模式是采用继承的方式实现这一点的：将逻辑(算法)框架放到抽象基类中，并定义好细节的接口，子类实现细节。
Strategy模式解决的是和Template模式类似的问题，但是Strategy模式是将逻辑(算法)封装到一个类中，并采取组合(委托)的方式解决问题的。

适用情况：
1) 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。
2) 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。其实这可以说是一种好的编码习惯了。
3) 控制子类扩展。模板方法只在特定点调用操作，这样就只允许在这些点进行扩展。比如上面runBare（）方法就只在runTest前面适用setUp方法。
如果你不愿子类来修改你的模板方法定义的框架，
你可以采用两种方式来做：
一是在API中不体现出你的模板方法；
二、将你的模板方法置为final就可以了。
　　可以看出，使用模板方法模式可以将代码的公共行为提取出来，达到复用的目的。
而且，在模板方法模式中，是由父类的模板方法来控制子类中的具体实现。
这样你在实现子类的时候，根本不需要对业务流程有太多的了解。



模板方法(Template Method)模式是GOF设计模式中最为常见几个模式之一。现在流行的很多框架中(如Spring，struts等)，我们都可以看到模板方法模式的广泛应用。模板方法模式主要应用于框架设计中，在日常的应用设计中也被经常使用。
   可是，我们在运用模板方法模式来解决我们的需求而进行设计时，往往忽略了一些非常重要的细节。保证架构逻辑的正常执行，不被子类破坏；怎么让子类扩展模板方法等。

1. 模板方法设计模式的意图
通常我们会遇到这样的一个问题：我们知道一个算法所需的关键步聚，并确定了这些步聚的执行顺序。但是某些步聚的具体实现是未知的，或者是某些步聚的实现与具体的环境相关。
模板方法模式把我们不知道具体实现的步聚封装成抽象方法，提供一些按正确顺序调用它们的具体方法(这些具体方法统称为模板方法),这样构成一个抽象基类。子类通过继承这个抽象基类去实现各个步聚的抽象方法，而工作流程却由父类来控制。

考虑一个简单的订单处理需求:一个客户可以在个订货单中订购多个货物(也称为订货单项目)，货物的销售价是根据货物的进货价进行计算的。有些货物可以打折的，有些是不可以打折的。每一个客户都有一个信用额度，每张订单的总价不能超出该客户的信用额度。

根据上面的业务，我们可以知道处理一个订单需要的步聚:
1. 遍历订货单的订货单项目列表，累加所有货物的总价格(根据订货单项目计算出销售价)
2. 根据客户号获得客户的信用额度
3. 把客户号，订单的总价格，及订单项目列表写入到数据库

但是我们并不能确定怎么计算出货物的销售价，怎样根据客户号获得客户的信用额度及把订单信息写入数据库这些方法的具体实现。
所以用一个抽象类AbstractOrder确定订单处理的逻辑，把不能确定的方法定义为抽象方法,由子类去完成具体的实现。